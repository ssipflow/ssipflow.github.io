---
title: \[Cloud Native\] 클라우드 네이티브 애플리케이션의 연결성 패턴
layout: single
author_profile: true
comments: true
share: true
related: false
date: '2024-07-30'
tags:
    - Cloud Native Application
category: Cloud Native Application
timezone: Asia/Seoul
---

# 연결성 패턴(Connectivity Patterns)이란?
클라우드 네이티브 애플리케이션에서 연결성 패턴은 서비스 간의 상호작용을 관리하고 최적화하는 데 중요하다.
이번 포스팅에서는 서비스 연결성, 서비스 추상화, 서비스 레지스트리 및 검색, 서비스 탄력성, 사이드카, 서비스 메시 및 사드카 없는 서비스 메시와 같은 주요 패턴을 다루고, 각 패턴에 대한 구체적인 예시를 제공한다.

# 주요 연결성 패턴
## 1. 서비스 연결성(Service Connectivity)
* 서비스 연결성은 서비스가 서로 어떻게 통신하고 데이터와 기능을 교환하는지를 정의한다. 클라우드 네이티브 애플리케이션에서는 서비스 간의 연결을 효율적으로 관리하고, 동적이고 자동화된 연결 방식을 지원하는 것이 중요하다.
* **마이크로서비스 아키텍처**
  * 마이크로 서비스 아키텍처를 사용하는 대형 전자상거래 플랫폼에서, 주문 서비스가 사용자 서비스와 통신하여 사용자의 구매 이력을 확인하고, 재고 서비스와 통신하여 재고를 업데이트 한다. 
  예를 들어, Amazon에서는 사용자 주문과 관련된 정보가 다양한 서비스에 의해 처리되며, 각 서비스는 HTTP/REST API를 통해 통신한다.
* 장점: 서비스 간의 월활한 통신을 통해 시스템의 전체적인 일관성과 응답성을 높일 수 있다.
* 단점: 서비스 간 연결의 복잡성이 증가할 수 있으며, 관리와 모니터링이 필요하다.

## 2. 서비스 추상화(Service Abstraction)
* 서비스 추상화는 서비스의 구현 세부사항을 숨기고, 서비스가 제공하는 기능만을 외부에 노출하는 방식이다. 이는 서비스의 내부 동작을 변경하더라도 외부 시스템에 영향을 주지 않도록 한다.
* **API Gateway**
  * Amazon API Gateway를 사용하여 백엔드 서비스가 다양한 API 요청을 처리하도록 하고, 클라이언트는 API Gateway를 통해서만 서비스에 접근한다.
  예를 들어, 클라이언트가 사용자 프로필 정보를 업데이트하고자 할 때, API Gateway가 요청을 받아 적절한 마이크로서비스로 라우팅한다.
  API Gateway는 요청을 검증하고, 인증 및 인가를 처리하며, 서비스의 변경 사항에 상관없이 클라이언트에는 일관된 인터페이스를 제공한다.
* 장점: 서비스의 내부 변경에 유연하게 대응할 수 있으며, 인터페이스 변경 시 시스템의 영향을 최소화할 수 있다.
* 단점: 추상화 레이어가 추가됨으로써 시스템의 복잡성이 증가할 수 있다.

## 3. 서비스 레지스트리 및 검색(Service Registry and Discovery)
* 서비스 레지스트리는 서비스의 인스턴스와 그 위치를 중앙에서 관리하는 기능을 제공한다. 서비스 검색은 클라이언트가 서비스 인스턴스의 위치를 동적으로 찾는 방법이다.
* **Eureka**
  * Netflix의 Eureka를 사용하여 마이크로서비스가 동적으로 등록되고 검색된다. 
  예를 들어, 사용자가 주문을 요청할 떄, 주문서비스는 Eureka에 자신을 등록하고, 클라이언트는 Eureka에서 주문 서비스의 위치를 조회하여 요청을 전달한다. 
  Eureka는 서비스 인스턴스의 상태를 모니터링하고, 서비스의 가용성을 보장한다.
* 장점: 동적인 서비스 인스턴스 관리와 로드 밸런싱을 지원하며, 서비스가 유연하게 추가되거나 제거될 수 있다.
* 단점: 서비스 레지스트리와 검색 기능의 구현과 유지 관리가 필요하며, 서비스 위치 정보를 중앙에서 관리해야 한다.

## 4. 서비스 탄력성(Service Resilience)
* 서비스 탄력성은 시스템의 장애와 오류 상황에서도 안정적으로 서비스를 제공하는 능력을 말한다. 이는 장애를 격리하고, 실패한 요청을 재시도하거나 대체 경로를 제공하는 방식으로 구현된다.
* **서킷브레이커(Circuit Breaker)**
  * Netflix의 Hystrix를 사용하여 서비스 호출의 실패를 감지하고, 서비스 장애가 발생하면 서킷을 열어 서비스 호출을 차단한다. 
  예를 들어, 결제 서비스가 외부 결제 게이트웨이에 연결되어 있을 때, 결제 게이트웨이에 장애가 발생하면 Hystrix는 서킷을 열어 요청을 차단하고, 일정시간이 지나면 다시 시도한다. 
  이 방식은 장애를 격리하고 시스템의 전체적인 안정성을 높인다.
* 장점: 시스템의 안정성을 높이고, 서비스 중단 시간을 줄일 수 있다.
* 단점: 탄력성을 구현하는 데 추가적인 오버헤드와 복잡성이 발생할 수 있다.

## 5. 사이드카 패턴(Sidecar Pattern)
* 사이드카 패턴은 애플리케이션과 함께 배포되는 추가적인 사이드카 컨테이너를 사용하여 애플리케이션의 기능을 확장한다. 사이드카는 로깅, 모니터링, 보안 등의 부가적인 기능을 제공할 수 있다.
* **Envoy**
  * Envoy를 사이드카 컨테이너로 사용하여 서비스의 트래픽을 관리한다.
  예를 들어, Kubernetes 클러스터에서 Envoy를 사이드카로 배포하여 서비스 간의 트래픽을 제어하고, 로깅과 모니터링을 수행한다. Envoy는 서비스 간의 트래픽을 제어하고, 로드 밸런싱, 트래픽 샤핑 및 장애 조치 기능을 제공한다.
* 장점: 애플리케이션의 주요 기능에 영향을 주지 않고, 추가 기능을 쉽게 통합할 수 있다.
* 단점: 사이드카와 애플리케이션 간의 통신을 관리해야 하며, 리소스 소모가 증가할 수 있다.

## 6. 서비스 메시(Service Mesh)
* 서비스 메시 패턴은 서비스 간의 통신을 관리하는 데 사용되는 인프라 계층이다. 서비스 메시를 사용하면 서비스 간의 통신을 제어하고 모니터링할 수 있으며, 보안, 트래픽 관리, 장애 조치 등을 지원한다.
* **Istio**
  * Istio는 서비스 메시를 구현하는 플랫폼으로, 서비스 간의 트래픽을 제어하고, 보안 및 관찰 기능을 제공한다. 예를 들어, Istio를 사용하여 서비스 간의 TLS 암호화를 구현하고, 트래픽을 관리하여 A/B테스트와 블루/그린 배포를 지원한다. 
  Istio는 사이드카 프록시를 사용하여 모든 서비스 간의 통신을 관리한다.
* 장점: 통합된 서비스 통신, 보안 및 관찰 기능 제공, 트래픽 관리
* 단점: 추가적인 복잡성과 성능 오버헤드가 발생할 수 있다.

## 7. 사이드카 없는 서비스 메시(Service Mesh Without Sidecar)
* 사이드카 없는 서비스 메시 패턴은 사이드카 없이 서비스 메시 기능을 제공하는 방식이다. 이 방법은 서비스 메시 기능을 애플리케이션 내에 직접 통합하거나, 다른 방식으로 관리하는 접근 방식이다.
* **Linkerd** 
  * Linkerd는 사이드카 없이도 서비스 메시 기능을 제공할 수 있는 플랙폼으로, 간단한 에이전트를 통해 서비스 간의 통신을 관리한다. Linkerd는 경량의 프록시를 사용하여 서비스 간의 통신을 제어하고, 트래픽을 관리하며, 보안 및 모니터링 기능을 제공한다.
* 장점: 사이드카 컨테이너를 사용하지 않아 오버헤드를 줄일 수 있으며, 사이드카 관리의 복잡성을 피할 수 있다.
* 단점: 기능 구현이 복잡해질 수 있으며, 서비스 메시의 모든 기능을 내장하는 데 추가적인 개발 노력이 필요하다.

# 연결성 패턴 선택의 기준
연결성 패턴을 선택할 때는 다음과 같은 기준을 고려해야 한다.
* **서비스의 독립성**: 서비스 간의 결합도와 독립성
* **시스템의 확장성**: 서비스 확장의 용이성과 유연성
* **복잡성 관리**: 시스템의 복잡성을 관리하는 데 필요한 도구와 접근 방식
* **성능**: 성능 요구 사항 및 오버헤드 고려

# 결론
연결성 패턴은 클라우드 네이티브 애플리케이션의 설계에서 중요한 역랑릉 한다. 서비스 간의 연결을 효과적으로 관리하고, 시스템의 유연성과 확장성을 확보하기 위해 다양한 패턴을 이해하고 적절히 활용하는 것이 필수이다.
각 패턴의 장단점을 잘 이해하고, 시스템 요구사항에 맞는 적절한 패턴을 선택하는 것이 성공적인 애플리케이션 구축의 핵심이다.