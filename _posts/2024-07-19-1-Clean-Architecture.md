---
title: \[Clean Architecture \#1\] Clean Architecture 개요
layout: single
author_profile: true
comments: true
share: true
related: true
date: '2024-07-19'
tags:
    - Design Pattern
    - Clean Architecture
    - SOLID
category: Clean Architecture
---

# Clean Architecture: 유지보수성과 확장성을 극대화하는 아키텍처 패턴
소프트웨어 개발의 궁극적인 목표는 높은 유지보수성과 확장성을 갖춘 시스템을 구축하는 것이다. 
이를 위해서는 명확한 아키텍처 패턴을 적용하는 것이 중요하다. 
Clean Architecture는 이러한 목표를 달성하기 위한 아키텍처 패턴 중 하나로, 복잡한 시스템을 모듈화하여 이해하기 쉽고, 변경과 확장이 용이하도록 설계된 패턴이다.

## Clean Architecture 란?
Clean Architecture는 Robert C. Martin이 제안한 아키텍처 패턴으로, 시스템을 여러 계층으로 나누어 각 계층 간의 의존성을 명확히 하고 특정 계층의 변경이 다른 계층에 미치는 영향을 최소화하는 것이 핵심이다.
이 패턴은 소프트웨어 유지보수성과 확장성을 극대화하기 위해 설계되었다.

|![Clean Architecture Layer](/assets/images/static/240719/CleanArchitecture.png){: width="70%" height="70%"}|
|:--:|
|Clean Architecture 구조|

## Clean Architecture의 계층
Clean Architecture는 크게 네 가지 주요 계층으로 구성된다. **외부에서 내부로 향할수록 고수준을 유지한다.**

### 1. Entities (엔터티)
엔터티는 애플리케이션의 비즈니스 규칙을 포함하는 객체들이다. 이들은 가장 안쪽에 위치하며, 시스템의 핵심 로직과 관련된 데이터를 정의한다.
엔터티는 다른 계층에 의존하지 않으며, 변경이 가장 적게 발생하는 계층이다.

### 2. Use Cases (유스케이스)
유스케이스 계층은 애플리케이션의 구체적인 비즈니스 로직을 구현한다. 유스케이스와 엔터티를 합쳐 도메인 영역이라고도 부른다.
이 계층은 엔터티를 사용하여 특정 작업을 수행하며, 시스템의 동작을 정의한다. 유스케이스는 외부영역(인터페이스 어댑터, 프레임워크 영역)에 의존하지 않는다.
이 계층은 애플리케이션의 동작을 제어하고, 애플리케이션이 원하는 결과를 달성하는 데 필요한 모든 비즈니스 규칙을 캡슐화 한다.

### 3. Interface Adapters (인터페이스 어댑터)
인터페이스 어댑터 계층은 외부 세계와 애플리케이션의 내부 로직을 연결하는 역할을 한다.
이 계층에서는 컨트롤러, 프레젠터, 게이트웨이 등을 통해 데이터를 변환하고, 유스 케이스와 상호작용 한다.
이 계층은 데이터베이스, 웹 프레임워크, UI 등의 구체적인 구현체들과 상호작용하며, 이를 유스 케이스와 엔터티가 이해할 수 있는 형식으로 변환한다.

### 4. Framework & Drivers (프레임워크 및 드라이버)
가장 바깥쪽에 위치한 이 계층은 데이터베이스, 웹 프레임워크, UI 등 외부 시스템과의 통합을 담당한다. 
이 계층은 구체적인 기술 스택을 포함하며, 다른 계층과의 의존성을 최소화해야 한다. 
이 계층은 주로 기술적 세부 사항에 해당하며, 시스템의 다른 부분에 영향을 미치지 않고 교체가 가능해야 한다.

## 계층간 의존성
Clean Architecture의 중요한 원칙 중 하나는 계층 간의 의존성 방향이다. **의존성은 항상 외부 계층에서 내부 계층으로 향해야 한다.**
즉, 저수준 모듈이 고수준 모듈에 의존하는 것이다. 이를 통해 고수준 모듈이 독립적으로 변화할 수 있게 된다.

## DIP (의존성 역전원칙)
Clean Architecture의 또다른 중요한 원칙은 의존성 역전원칙(DIP)이다. DIP 는 고수준모듈이 저수준 모듈에 의존하지 않고, **추상화에 의존**하도록 만드는 원칙이다. 
이를 통해 시스템의 유연성과 재사용성을 극대화할 수 있다.

고수준 모듈이 저수준 모듈을 직접 참조해야 할 경우, 인터페이스나 추상 클래스를 사용하여 두 모듈 같의 의존성을 분리한다. 이를 통해 고수준 모듈은 저수준 모듈의 구체적인 구현에 의존하지 않게 되며, 쉽게 교체하고 확장할 수 있다.

## Clean Architecture의 이점
1. 유지보수성: 각 계층이 명확히 분리되어 있어 변경이 필요할 때 특정 계층만 수정하면 되므로 유지보수가 용이하다.
2. 테스트 용이성: 비즈니스 로직과 외부 종속성이 분리되어 있어 유닛 테스트를 쉽게 작성할 수 있다.
3. 유연성 및 확장성: 시스템의 한 계층을 다른 계층에 영향을 주지 않고 확장할 수 있어 유연한 아키텍처를 구성할 수 있다.
4. 독립성: 비즈니스 로직이 프레임워크나 드라이버에 의존하지 않으므로, 기술 스택의 변화에도 대응하기 쉽다.

# 결론
Clean Architecture는 복잡한 소프트웨어 시스템을 모듈화하고, 유지보수성과 확장성을 극대화하는 데 매우 효과적인 아키텍처 패턴이다. 이 아키텍처를 통해 각 계층 간의 의존성을 명확히 하고, 변경에 유연하게 대응할 수 있다.
Clean Architecture를 적용하면, 시스템의 이해도와 관리 효율성이 크게 향상된다. 앞으로 소프트웨어를 설계할 때 Clean Architecture 를 고려해 보길 바란다.